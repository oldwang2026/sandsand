//==============================================================================
//  WARNING!!  This file is overwritten by the Block UI Styler while generating
//  the automation code. Any modifications to this file will be lost after
//  generating the code again.
//
//       Filename:  C:\shotpeening\application\SprayCurveBuilder.cpp
//
//        This file was generated by the NX Block UI Styler
//        Created by: PC
//              Version: NX 2306
//              Date: 09-19-2025  (Format: mm-dd-yyyy)
//              Time: 20:29 (Format: hh-mm)
//
//==============================================================================

//==============================================================================
//  Purpose:  This TEMPLATE file contains C++ source to guide you in the
//  construction of your Block application dialog. The generation of your
//  dialog file (.dlx extension) is the first step towards dialog construction
//  within NX.  You must now create a NX Open application that
//  utilizes this file (.dlx).
//
//  The information in this file provides you with the following:
//
//  1.  Help on how to load and display your Block UI Styler dialog in NX
//      using APIs provided in NXOpen.BlockStyler namespace
//  2.  The empty callback methods (stubs) associated with your dialog items
//      have also been placed in this file. These empty methods have been
//      created simply to start you along with your coding requirements.
//      The method name, argument list and possible return values have already
//      been provided for you.
//==============================================================================

//------------------------------------------------------------------------------
//These includes are needed for the following template code
//------------------------------------------------------------------------------
#include "SprayCurveBuilder.hpp"
#include <NXOpen/DisplayManager.hxx>
#include <NXOpen/NXObjectManager.hxx>
#include <uf_layer.h>
#include <sstream>
#include <iomanip>
using namespace NXOpen;
using namespace NXOpen::BlockStyler;

//------------------------------------------------------------------------------
// Initialize static variables
//------------------------------------------------------------------------------
Session *(SprayCurveBuilder::theSession) = NULL;
UI *(SprayCurveBuilder::theUI) = NULL;
//------------------------------------------------------------------------------
// Constructor for NX Styler class
//------------------------------------------------------------------------------
SprayCurveBuilder::SprayCurveBuilder()
{
    try
    {
        // Initialize the NX Open C++ API environment
        SprayCurveBuilder::theSession = NXOpen::Session::GetSession();
        SprayCurveBuilder::theUI = UI::GetUI();
        theDlxFileName = "SprayCurveBuilder.dlx";
        theDialog = SprayCurveBuilder::theUI->CreateDialog(theDlxFileName);
        // Registration of callback functions
        theDialog->AddApplyHandler(make_callback(this, &SprayCurveBuilder::apply_cb));
        theDialog->AddOkHandler(make_callback(this, &SprayCurveBuilder::ok_cb));
        theDialog->AddUpdateHandler(make_callback(this, &SprayCurveBuilder::update_cb));
        theDialog->AddInitializeHandler(make_callback(this, &SprayCurveBuilder::initialize_cb));
        theDialog->AddDialogShownHandler(make_callback(this, &SprayCurveBuilder::dialogShown_cb));
    }
    catch(exception& ex)
    {
        //---- Enter your exception handling code here -----
        throw;
    }
}

//------------------------------------------------------------------------------
// Destructor for NX Styler class
//------------------------------------------------------------------------------
SprayCurveBuilder::~SprayCurveBuilder()
{
    if (theDialog != NULL)
    {
        delete theDialog;
        theDialog = NULL;
    }
}


//------------------------------------------------------------------------------
// This method specifies how a shared image is unloaded from memory
// within NX. This method gives you the capability to unload an
// internal NX Open application or user  exit from NX. Specify any
// one of the three constants as a return value to determine the type
// of unload to perform:
//
//
//    Immediately : unload the library as soon as the automation program has completed
//    Explicitly  : unload the library from the "Unload Shared Image" dialog
//    AtTermination : unload the library when the NX session terminates
//
//
// NOTE:  A program which associates NX Open applications with the menubar
// MUST NOT use this option since it will UNLOAD your NX Open application image
// from the menubar.
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
//This method launches the dialog to screen
//------------------------------------------------------------------------------
NXOpen::BlockStyler::BlockDialog::DialogResponse SprayCurveBuilder::Launch()
{
    NXOpen::BlockStyler::BlockDialog::DialogResponse dialogResponse= NXOpen::BlockStyler::BlockDialog::DialogResponse::DialogResponseInvalid;
    try
    {
        dialogResponse=theDialog->Launch();
    }
    catch(exception& ex)
    {
        //---- Enter your exception handling code here -----
        SprayCurveBuilder::theUI->NXMessageBox()->Show("Block Styler", NXOpen::NXMessageBox::DialogTypeError, ex.what());
    }
    return dialogResponse;
}

//------------------------------------------------------------------------------
//---------------------Block UI Styler Callback Functions--------------------------
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
//Callback Name: initialize_cb
//------------------------------------------------------------------------------
void SprayCurveBuilder::initialize_cb()
{
    try
    {
        group = dynamic_cast<NXOpen::BlockStyler::Group*>(theDialog->TopBlock()->FindBlock("group"));
        bodySelect0 = dynamic_cast<NXOpen::BlockStyler::BodyCollector*>(theDialog->TopBlock()->FindBlock("bodySelect0"));
        group1 = dynamic_cast<NXOpen::BlockStyler::Group*>(theDialog->TopBlock()->FindBlock("group1"));
        reg_box = dynamic_cast<NXOpen::BlockStyler::ListBox*>(theDialog->TopBlock()->FindBlock("reg_box"));
        group2 = dynamic_cast<NXOpen::BlockStyler::Group*>(theDialog->TopBlock()->FindBlock("group2"));
        highlightselection = dynamic_cast<NXOpen::BlockStyler::CurveCollector*>(theDialog->TopBlock()->FindBlock("highlightselection"));
        crv_box = dynamic_cast<NXOpen::BlockStyler::ListBox*>(theDialog->TopBlock()->FindBlock("crv_box"));
        group3 = dynamic_cast<NXOpen::BlockStyler::Group*>(theDialog->TopBlock()->FindBlock("group3"));
        d_sprayDiameter = dynamic_cast<NXOpen::BlockStyler::DoubleBlock*>(theDialog->TopBlock()->FindBlock("d_sprayDiameter"));
        d_overlapRatio = dynamic_cast<NXOpen::BlockStyler::DoubleBlock*>(theDialog->TopBlock()->FindBlock("d_overlapRatio"));
        d_smallEdgeThreshold = dynamic_cast<NXOpen::BlockStyler::DoubleBlock*>(theDialog->TopBlock()->FindBlock("d_smallEdgeThreshold"));
        d_tinyEdgeThreshold = dynamic_cast<NXOpen::BlockStyler::DoubleBlock*>(theDialog->TopBlock()->FindBlock("d_tinyEdgeThreshold"));
        button0 = dynamic_cast<NXOpen::BlockStyler::Button*>(theDialog->TopBlock()->FindBlock("button0"));
        button01 = dynamic_cast<NXOpen::BlockStyler::Button*>(theDialog->TopBlock()->FindBlock("button01"));

        d_sprayDiameter->SetValue(80.0);      // 默认喷砂直径80mm
        d_overlapRatio->SetValue(0.3);        // 默认重叠率30%
        d_smallEdgeThreshold->SetValue(15.0); // 默认小边阈值15mm
        d_tinyEdgeThreshold->SetValue(5.0);   // 默认极小边阈值5mm

        //------------------------------------------------------------------------------
        //Registration of ListBox specific callbacks
        //------------------------------------------------------------------------------
        //reg_box->SetAddHandler(make_callback(this, &SprayCurveBuilder::AddCallback));
        
        //reg_box->SetDeleteHandler(make_callback(this, &SprayCurveBuilder::DeleteCallback));
        
        //------------------------------------------------------------------------------
    }
    catch(exception& ex)
    {
        //---- Enter your exception handling code here -----
        SprayCurveBuilder::theUI->NXMessageBox()->Show("Block Styler", NXOpen::NXMessageBox::DialogTypeError, ex.what());
    }
}

//------------------------------------------------------------------------------
//Callback Name: dialogShown_cb
//This callback is executed just before the dialog launch. Thus any value set 
//here will take precedence and dialog will be launched showing that value. 
//------------------------------------------------------------------------------
void SprayCurveBuilder::dialogShown_cb()
{
    try
    {
        //---- Enter your callback code here -----
    }
    catch(exception& ex)
    {
        //---- Enter your exception handling code here -----
        SprayCurveBuilder::theUI->NXMessageBox()->Show("Block Styler", NXOpen::NXMessageBox::DialogTypeError, ex.what());
    }
}

//------------------------------------------------------------------------------
//Callback Name: apply_cb
//------------------------------------------------------------------------------
int SprayCurveBuilder::apply_cb()
{
    int errorCode = 0;
    try
    {
        //---- Enter your callback code here -----
#ifndef _MYDEBUG 
        RegionCurveBuilder::CleanupNonPathCurves();
#endif // DEBUG
    }
    catch(exception& ex)
    {
        //---- Enter your exception handling code here -----
        errorCode = 1;
        SprayCurveBuilder::theUI->NXMessageBox()->Show("Block Styler", NXOpen::NXMessageBox::DialogTypeError, ex.what());
    }
    return errorCode;
}

//------------------------------------------------------------------------------
//Callback Name: update_cb
//------------------------------------------------------------------------------
int SprayCurveBuilder::update_cb(NXOpen::BlockStyler::UIBlock* block)
{
    try
    {
        if(block == bodySelect0)
        {
        //---------Enter your code here-----------
            auto bodysel = bodySelect0->GetSelectedObjects()[0];
            
            m_regionbuilder.Commit(bodysel);
            set_regbox_item(m_regionbuilder);

            if (reg_box->GetListItems().size()>1)
            {
                DisplayableObject* hideobj = dynamic_cast<DisplayableObject*>(bodysel);
                std::vector<NXOpen::DisplayableObject*> objects1(1);
                objects1[0] = hideobj;
                theSession->DisplayManager()->BlankObjects(objects1);
                bodySelect0->SetEnable(false);
            }
            UF_LAYER_set_status(81, UF_LAYER_WORK_LAYER);

        }
        else if(block == reg_box)
        {
        //---------Enter your code here-----------
         regbox_select_update();
        }
        else if(block == highlightselection)
        {
        //---------Enter your code here-----------
        }
        else if(block == crv_box)
        {
        //---------Enter your code here-----------
          crvbox_select_update();

        }
        else if(block == d_sprayDiameter)
        {
        //---------Enter your code here-----------
            m_curveBuilder.UpdateParametersFromUI(
                d_sprayDiameter->Value(),
                d_overlapRatio->Value(),
                d_smallEdgeThreshold->Value(),
                d_tinyEdgeThreshold->Value()
            );
        }
        else if(block == d_overlapRatio)
        {
        //---------Enter your code here-----------
            m_curveBuilder.UpdateParametersFromUI(
                d_sprayDiameter->Value(),
                d_overlapRatio->Value(),
                d_smallEdgeThreshold->Value(),
                d_tinyEdgeThreshold->Value()
            );
        }
        else if(block == d_smallEdgeThreshold)
        {
        //---------Enter your code here-----------
            m_curveBuilder.UpdateParametersFromUI(
                d_sprayDiameter->Value(),
                d_overlapRatio->Value(),
                d_smallEdgeThreshold->Value(),
                d_tinyEdgeThreshold->Value()
            );
        }
        else if(block == d_tinyEdgeThreshold)
        {
        //---------Enter your code here-----------
            m_curveBuilder.UpdateParametersFromUI(
                d_sprayDiameter->Value(),
                d_overlapRatio->Value(),
                d_smallEdgeThreshold->Value(),
                d_tinyEdgeThreshold->Value()
            );
        }
        else if(block == button0)
        {
        //---------Enter your code here-----------
         GenerateSprayPath();
        }
        else if (block == button01)
        {
            //GenerateDistanceFieldPath();
        }
    }
    catch(exception& ex)
    {
        //---- Enter your exception handling code here -----
        SprayCurveBuilder::theUI->NXMessageBox()->Show("Block Styler", NXOpen::NXMessageBox::DialogTypeError, ex.what());
    }
    return 0;
}

//------------------------------------------------------------------------------
//Callback Name: ok_cb
//------------------------------------------------------------------------------
int SprayCurveBuilder::ok_cb()
{
    int errorCode = 0;
    try
    {
        errorCode = apply_cb();
    }
    catch(exception& ex)
    {
        //---- Enter your exception handling code here -----
        errorCode = 1;
        SprayCurveBuilder::theUI->NXMessageBox()->Show("Block Styler", NXOpen::NXMessageBox::DialogTypeError, ex.what());
    }
    return errorCode;
}
//------------------------------------------------------------------------------
//ListBox specific callbacks
//------------------------------------------------------------------------------
//int SprayCurveBuilder::AddCallback (NXOpen::BlockStyler::ListBox* list_box)
//{
//}

//int SprayCurveBuilder::DeleteCallback(NXOpen::BlockStyler::ListBox* list_box)
//{
//}

//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
//Function Name: GetBlockProperties
//Description: Returns the propertylist of the specified BlockID
//------------------------------------------------------------------------------
PropertyList* SprayCurveBuilder::GetBlockProperties(const char *blockID)
{
    return theDialog->GetBlockProperties(blockID);
}

void SprayCurveBuilder::set_regbox_item(RegionBuilder& regionbuilder)
{
    try
    {
        // 清空ListBox中现有的项
        std::vector<NXString> emptyList;
        reg_box->SetListItems(emptyList);

        // 获取所有区域
        const std::vector<Region>& regions = regionbuilder.getRegions();

        // 创建列表项字符串数组
        std::vector<NXString> regionItems;
        regionItems.reserve(regions.size());

        // 为每个区域创建显示字符串
        for (const Region& region : regions) {
            // 创建区域名称，格式为"区域0"、"区域1"等
            std::string regionName = "区域" + std::to_string(region.id);

            // 可选：添加更多信息，如类型和面数
            std::string typeStr;
            switch (region.type) {
            case FaceRegionType::HORIZONTAL:
                typeStr = " [水平]";
                break;
            case FaceRegionType::CONVEX:
                typeStr = " [凸面]";
                break;
            case FaceRegionType::CONCAVE:
                typeStr = " [凹面]";
                break;
            case FaceRegionType::SIDEWALL:
                typeStr = " [侧壁]";
                break;
            case FaceRegionType::UNSORTED:
                typeStr = " [未分类]";
                break;
            }

            // 添加面数信息
            regionName += typeStr;
           

            // 如果是环形区域，添加标记
            if (region.isRing) {
                regionName += " [环形]";
            }

            // 如果该区域已处理，添加"已处理"标记
            if (region.processed) {
                regionName += " 已处理";
            }

            // 将字符串添加到列表
            regionItems.push_back(NXString(regionName));
        }

        reg_box->SetListItems(regionItems);
    }
    catch (exception& ex)
    {
        SprayCurveBuilder::theUI->NXMessageBox()->Show("设置区域列表",
            NXOpen::NXMessageBox::DialogTypeError, ex.what());
    }
}

void SprayCurveBuilder::regbox_select_update()
{
    try
    {
        // 清空曲线组列表
        std::vector<NXString> emptyList;
        crv_box->SetListItems(emptyList);
       
        // 获取当前选中的区域索引
        std::vector<int> selectedIndices = reg_box->GetSelectedItems();
        if (selectedIndices.empty()) {
            return;  // 没有选中任何区域
        }

        int selectedIndex = selectedIndices[0];  // 获取第一个选中项

        // 获取所有区域
        std::vector<Region>& regions = m_regionbuilder.getRegions();

        // 检查索引有效性
        if (selectedIndex >= regions.size()) {
            return;
        }

        // 获取选中的区域
        Region& selectedRegion = regions[selectedIndex];

        // 创建RegionCurveBuilder实例来分析边界
        RegionCurveBuilder curveBuilder;



        // 分析边界，生成boundaryGroups
        bool analysisResult = curveBuilder.AnalyzeBoundaries(selectedRegion);

        if (!analysisResult) {
            // 分析失败，可能是环形区域或其他问题
            std::vector<NXString> errorMsg;
            if (selectedRegion.isRing) {
                errorMsg.push_back(NXString("环形区域暂不支持"));
            }
            else {
                errorMsg.push_back(NXString("边界分析失败"));
            }
            crv_box->SetListItems(errorMsg);
            return;
        }

        // 获取边界组数量
        int groupCount = curveBuilder.GetBoundaryGroupCount(selectedRegion);

        // 创建显示列表
        std::vector<NXString> boundaryGroupItems;
        boundaryGroupItems.reserve(groupCount);

        for (int i = 0; i < groupCount; i++) {
            // 获取每个边界组
            std::vector<RegionBoundaryEdgeInfo> group =
                curveBuilder.GetBoundaryGroup(selectedRegion, i);

            // 创建显示字符串
            std::string groupName = "边界组" + std::to_string(i);
            groupName += " (边数:" + std::to_string(group.size()) + ")";

            boundaryGroupItems.push_back(NXString(groupName));
        }

        // 设置到crv_box
        if (!boundaryGroupItems.empty()) {
            crv_box->SetListItems(boundaryGroupItems);

        }
        else {
            std::vector<NXString> noGroupMsg;
            noGroupMsg.push_back(NXString("未识别到边界组"));
            crv_box->SetListItems(noGroupMsg);
        }

    }
    catch (exception& ex)
    {
        SprayCurveBuilder::theUI->NXMessageBox()->Show("更新边界组列表",
            NXOpen::NXMessageBox::DialogTypeError, ex.what());
    }
}

void SprayCurveBuilder::crvbox_select_update()
{
    try
    {
        // 获取选中的索引
        std::vector<int> crvSelected = crv_box->GetSelectedItems();
        std::vector<int> regSelected = reg_box->GetSelectedItems();

        if (crvSelected.empty() || regSelected.empty()) {
            // 清空高亮
            std::vector<TaggedObject*> empty;
            highlightselection->SetSelectedObjects(empty);
            return;
        }

        // 获取边界组
        std::vector<Region>& regions = m_regionbuilder.getRegions();
        Region& region = regions[regSelected[0]];
        const std::vector<RegionBoundaryEdgeInfo>& group =
            region.boundaryGroups[crvSelected[0]];

        // 收集边
        std::vector<TaggedObject*> edges;
        for (const auto& edgeInfo : group) {
           
            edges.push_back(NXOpen::NXObjectManager::Get(edgeInfo.boundarycurvetag));
        }

        // 设置高亮
        highlightselection->SetSelectedObjects(edges);
        highlightselection->Focus();
    }
    catch (exception& ex)
    {
        SprayCurveBuilder::theUI->NXMessageBox()->Show("高亮边界组",
            NXOpen::NXMessageBox::DialogTypeError, ex.what());
    }
}


void SprayCurveBuilder::GenerateSprayPath()
{
    try
    {


        m_curveBuilder.UpdateParametersFromUI(
            d_sprayDiameter->Value() ,
            d_overlapRatio->Value(),
            d_smallEdgeThreshold->Value(),
            d_tinyEdgeThreshold->Value()
        );

        // 1. 获取选中的区域索引
        std::vector<int> regSelected = reg_box->GetSelectedItems();
        if (regSelected.empty()) {
            SprayCurveBuilder::theUI->NXMessageBox()->Show("喷砂路径生成",
                NXOpen::NXMessageBox::DialogTypeWarning, "请先选择一个区域");
            return;
        }

        // 2. 获取选中的边界组索引
        std::vector<int> crvSelected = crv_box->GetSelectedItems();
        if (crvSelected.empty()) {
            SprayCurveBuilder::theUI->NXMessageBox()->Show("喷砂路径生成",
                NXOpen::NXMessageBox::DialogTypeWarning, "请先选择一个边界组");
            return;
        }

        // 3. 获取选中的区域
        std::vector<Region>& regions = m_regionbuilder.getRegions();
        if (regSelected[0] >= regions.size()) {
            return;
        }
        Region& selectedRegion = regions[regSelected[0]];



        // 5. 确保边界已分析
        if (!selectedRegion.boundaryAnalyzed) {
            bool analysisResult;
            if (selectedRegion.isRing) {
                // 环形区域使用专门的分析方法
                analysisResult = m_curveBuilder.AnalyzeRingBoundaries(selectedRegion);
            }
            else {
                analysisResult = m_curveBuilder.AnalyzeBoundaries(selectedRegion);
            }

            if (!analysisResult) {
                SprayCurveBuilder::theUI->NXMessageBox()->Show("喷砂路径生成",
                    NXOpen::NXMessageBox::DialogTypeError, "边界分析失败");
                return;
            }
        }

        // 6. 获取选中的边界组
        if (crvSelected[0] >= selectedRegion.boundaryGroups.size()) {
            return;
        }
        const std::vector<RegionBoundaryEdgeInfo>& selectedBoundaryGroup =
            selectedRegion.boundaryGroups[crvSelected[0]];

        // 7. 生成控制曲线（样条曲线）
        tag_t splineTag = NULL_TAG;
        int pointsPerEdge = 10;  // 每条边取10个点

        bool splineResult = m_curveBuilder.GenerateSplineFromBoundaryGroup(
            selectedBoundaryGroup,
            pointsPerEdge,
            &splineTag
        );

        if (!splineResult || splineTag == NULL_TAG) {
            SprayCurveBuilder::theUI->NXMessageBox()->Show("喷砂路径生成",
                NXOpen::NXMessageBox::DialogTypeError, "生成控制曲线失败");
            return;
        }

        // 8. 生成控制点
        std::vector<Point3d> controlPoints = m_curveBuilder.GenerateControlPoints(splineTag);

        if (controlPoints.empty()) {
            SprayCurveBuilder::theUI->NXMessageBox()->Show("喷砂路径生成",
                NXOpen::NXMessageBox::DialogTypeError, "生成控制点失败");
            return;
        }

        // 9. 将生成的数据存储到区域中
        // 清空之前的数据（仅清空选中边界组对应的数据）
        if (selectedRegion.controlPointGroups.size() <= crvSelected[0]) {
            // 扩展vector大小
            selectedRegion.controlPointGroups.resize(crvSelected[0] + 1);
            selectedRegion.splineTags.resize(crvSelected[0] + 1);
        }

        selectedRegion.controlPointGroups[crvSelected[0]] = controlPoints;
        selectedRegion.splineTags[crvSelected[0]] = splineTag;

        // 10. 临时创建只包含当前边界组的数据结构，用于路径生成
        Region tempRegion = selectedRegion;
        tempRegion.controlPointGroups.clear();
        tempRegion.splineTags.clear();
        tempRegion.sprayPathPoints.clear();
        tempRegion.sprayPathCurves.clear();

        tempRegion.controlPointGroups.push_back(controlPoints);
        tempRegion.splineTags.push_back(splineTag);

        // 11. 生成喷砂路径（使用改进的智能连接算法）
        bool pathResult = m_curveBuilder.GenerateSprayPathForRegion(tempRegion);

        if (!pathResult) {
            SprayCurveBuilder::theUI->NXMessageBox()->Show("喷砂路径生成",
                NXOpen::NXMessageBox::DialogTypeError, "生成喷砂路径失败");
            return;
        }

        // 12. 将生成的路径保存回原区域
        for (const auto& path : tempRegion.sprayPathPoints) {
            selectedRegion.sprayPathPoints.push_back(path);
        }
        for (const auto& curve : tempRegion.sprayPathCurves) {
            selectedRegion.sprayPathCurves.push_back(curve);
        }

        // 13. 可视化生成的路径
        std::vector<TaggedObject*> pathCurves;
        int validPathCount = 0;

        for (tag_t curveTag : tempRegion.sprayPathCurves) {
            if (curveTag != NULL_TAG) {
                TaggedObject* curve = NXOpen::NXObjectManager::Get(curveTag);
                if (curve) {
                    pathCurves.push_back(curve);
                    validPathCount++;

                    // 设置曲线颜色
                    DisplayableObject* displayObj = dynamic_cast<DisplayableObject*>(curve);
                    if (displayObj) {
                        // 根据是否为环形区域使用不同的颜色方案
                        if (selectedRegion.isRing) {
                            displayObj->SetColor(78);  // 环形区域用品红色
                        }
                        else {
                            displayObj->SetColor(186);  // 普通区域用红色
                        }
                        displayObj->RedisplayObject();
                    }
                }
            }
        }

        // 14. 标记该区域为已处理
        selectedRegion.processed = true;

        // 15. 刷新区域列表（显示"已处理"标记）
        set_regbox_item(m_regionbuilder);

        // 16. 在高亮选择框中显示生成的路径
        if (!pathCurves.empty()) {
            highlightselection->SetSelectedObjects(std::vector<TaggedObject*>(0));
            highlightselection->SetSelectedObjects(pathCurves);
            highlightselection->Focus();

            // 显示成功信息
            std::stringstream message;
            message << "成功生成喷砂路径！\n";
            message << "================\n";
            message << "区域类型: " << (selectedRegion.isRing ? "环形区域" : "普通区域") << "\n";
            message << "边界组索引: " << crvSelected[0] << "\n";
            message << "控制点数量: " << controlPoints.size() << "\n";
            message << "生成路径数: " << validPathCount << "\n";
            message << "================\n";


            SprayCurveBuilder::theUI->NXMessageBox()->Show("喷砂路径生成",
                NXOpen::NXMessageBox::DialogTypeInformation, message.str().c_str());
        }
        else {
            SprayCurveBuilder::theUI->NXMessageBox()->Show("喷砂路径生成",
                NXOpen::NXMessageBox::DialogTypeWarning, "未生成有效的路径曲线");
        }

    }
    catch (exception& ex)
    {
        SprayCurveBuilder::theUI->NXMessageBox()->Show("喷砂路径生成",
            NXOpen::NXMessageBox::DialogTypeError, ex.what());
    }
}





